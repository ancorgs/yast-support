/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	include/support/complex.ycp
 * Package:	Configuration of support
 * Summary:	Dialogs definitions
 * Authors:	Michal Zugec <mzugec@novell.com>
 *
 * $Id: complex.ycp 41350 2007-10-10 16:59:00Z dfiser $
 */

{

textdomain "support";

import "Label";
import "Popup";
import "Wizard";
//import "Wizard_hw";
import "Confirm";
import "Support";


include "support/helps.ycp";

/**
 * Return a modification status
 * @return true if data was modified
 */
boolean Modified() {
    return Support::Modified();
}

boolean ReallyAbort() {
    return !Support::Modified() || Popup::ReallyAbort(true);
}

boolean PollAbort() {
    return UI::PollInput() == `abort;
}

/**
 * Read settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol ReadDialog() {
    Wizard::RestoreHelp(HELPS["read"]:"");
    // Support::SetAbortFunction(PollAbort);
//    if (!Confirm::MustBeRoot()) return `abort;
    if (Support::WhoAmI() != 0)
    {
	// use configuration file in home directory
	string cmd = sformat ("ls %1", "~/.supportconfig");
	map out = (map)SCR::Execute (.target.bash_output, cmd);
	string file = out["stdout"]:"";
	file = splitstring (file, "\n")[0]:"";
	if (file == "" || file == nil)
	{
	    if (!Confirm::MustBeRoot()) return `abort;
	}
	y2milestone ("Using configuration file %1", file);
	setenv ("SC_CONF", file);
	// ensure ~/.supportconfig does exist
	if (SCR::Read (.target.size, file) < 0)
	{
	    string cmd = sformat ("/bin/cp %1 %2", "/etc/supportconfig.conf", file);
	    SCR::Execute (.target.bash, cmd);
	}
	SCR::UnregisterAgent(.etc.supportconfig);
	SCR::RegisterAgent (.etc.supportconfig, `ag_ini(
	    `IniAgent( file,
	        $[
	        "options" : [ "global_values", "comments_last", "line_can_continue", "join_multiline" ],
	        "comments": [
	            "^[ \t]*$", // empty line
	            "^[ \t]+[;#].*$", // comment char is not first char
	            "^[#][ \t]*$", // only comment chars
	            "^[#][ \t]*\\[[^]]*$", // comment chars followed by '[' without matching ']'
	            "^[#][^ \t[]", // comment char followed by non-blank nor '['
	            "^[#][ \t]+[^[a-z \t].*$", // comment chars followed by non a-z char nor '[' nor blank
	            "^[#][ \t]+[a-z ]*[a-z][ \t]*$", // comment chars followed by a-z or blank chars
	            "^[#][ \t]+[a-z ]*[a-z][ \t]*[^a-z \t=].*$", // like above, but followed by non a-z nor blank nor '=' chars
	        ],
	/*
	        "sections" : [
	            $[
	                "begin" : [ "^[ \t]*\\[[ \t]*(.*[^ \t])[ \t]*\\][ \t]*", "[%s]" ],
	            ], $[
	                // this is a special type for commenting out the values
	                "begin" : [ "^[#;][ \t]*\\[[ \t]*(.*[^ \t])[ \t]*\\][ \t]*", "# [%s]" ],
	            ]
	        ],
	*/
	        // we need to exclude ; because of the second matching rule
	        "params" : [
	                // Options with one value ('yes' / 'no')
	//                $[ "match" : [ "^[#;][ \t]*([^ \t]+)[ \t]+([^ \t]+)[ \t]+$", "%s %s" ]],
	//                $[ "match" : [ "^[#;][ \t]*([^ \t\=]+)[ \t\=]?(.+)[ \t]*$", "; %s %s" ]],
	                // Options with more possible values
	//                  $[ "match" :   [ "^[ \t]*([^ \t\=]+)[ \t\=]+[ ]*\"(.*)\"[ \t]*$", "%s=\"%s\"" ]],
	                // string
	                $[ "match" : [ "^[ \t]*([^ \t\=]+)[ \t\=]+[ ]*\"(.*)\"[[:space:]]*\#[\-[:space:][:alnum:]]*$", "%s=\"%s\"" ]],
	                $[ "match" : [ "^[ \t]*([^ \t\=]+)[ \t\=]+[ ]*\"(.*)\"[[:space:]]*$", "%s=\"%s\"" ]],
	                // number
	                $[ "match" : [ "^[ \t]*([^ \t\=]+)[ \t\=]+[ ]*([[:digit:]]+)[[:space:]]*\#[\-[:alnum:][:space:]]*$", "%s=%s" ]],
	                $[ "match" : [ "^[ \t]*([^ \t\=]+)[ \t\=]+[ ]*(.+)[[:space:]]*$", "%s=%s" ]],
	        ],
	       ]
	    )
	));
    }
    y2internal ("Read 2: %1", SCR::Read (.etc.supportconfig.all));

    boolean ret = Support::Read();
    return ret ? `next : `abort;
}

/**
 * Write settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol WriteDialog() {
    Wizard::RestoreHelp(HELPS["write"]:"");
    // Support::SetAbortFunction(PollAbort);
    boolean ret = Support::Write();
    return ret ? `next : `abort;
}



/* EOF */
}
